import sys

input = sys.stdin.readline

n = int(input())


dp = [[0, []] for _ in range(n + 1)]

dp[1][0] = 0
dp[1][1] = [1]

# 그냥 1더하기와 달리 경로까지 해야하니깐 2차원 배열로 설정
for i in range(2, n + 1):
    dp[i][0] = dp[i-1][0] + 1  # dp[i-1]보다는 최소 1번 더 연산하는거니깐 (빼기 고려)(2,3이니깐 1번만 빼면 둘중 아무거나 걸림)
    dp[i][1] = dp[i-1][1] + [i]
    if i % 3 == 0 and dp[i // 3][0] + 1 < dp[i][0]: # 이거는 잘 생각해보면 3으로 나눈거에 1번더 연산하는게 빠르냐 아니면 빼는게 빠르냐 고려한것 
        dp[i][0] = dp[i // 3][0] + 1
        dp[i][1] = dp[i // 3][1] + [i]
    if i % 2 == 0 and dp[i // 2][0] + 1 < dp[i][0]:
        dp[i][0] = dp[i // 2][0] + 1
        dp[i][1] = dp[i // 2][1] + [i]


print(dp[n][0])
print(*reversed(dp[n][1]))


# elif가 아니고 if인 이유? -> 2와 3으로 둘다 나뉘어질때를 고려해야한다
# 15줄은 빼기 고려, 17줄은 3나누기고려, 20줄은 2나누기고려 이것들중 최솟값으로 선언
# 빼기로 먼저 선언하고 그다음 3,2나누기를 비교해봤을때 더 연산이 적은것으로 선언