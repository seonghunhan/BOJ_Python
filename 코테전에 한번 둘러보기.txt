!!!너는 문제이해도가 낮아 그니까 문제에서 원하는 결과를 명확하게 해석하고 여러 경우의수를 고려할 것!!!!
1억 -> 1초
https://chancoding.tistory.com/43 -> 파이썬 자료구조의 메서드별 시간복잡도
중간에 찾는거는 해쉬가 사기급 d.fet(k) -> O(1)
이래저래 해쉬는 거의 O(1)을 보임
리스트의 sort는 N Log N임 -> 이분탐색 logN에서 N배된거 즉, O(N)보다는 느린데 쓸만함

써야하는 라이브러리!!
from itertools import combinations
from itertools import permutations
from collections import Counter
from functools import reduce
import heapq


1. str 문제관련
1.2) 리스트에 있는 str 한줄씩 출력
print('\n'.join(리스트이름))


1.2) 리스트에 있는 str 붙여서 출력 ['a', 'b', 'c', 'd'] -> abcd로 출력
temp = ['a', 'b', 'c', 'd']
print(''.join(map(str, temp)))


2) a s d -> ['a', 's', 'd']
board = [list(input().split()) for _ in range(N)]


3) asd -> ['a', 's', 'd']
asd = list(input().rstrip())

mineBoard = [list(input().rstrip()) for _ in range(N) ] -> 문자열 2차원배열

4) 문자열 두개를 비교하는거면 리스트에 넣지말고 그냥 str(input())으로 저장해서 다루기

4.1 ) 
isalnum() -> 받은 문자가 영어,한글,숫자면 True 반환
isalpha() -> 받은 문자가 영어,한글이면 True 반환


5) 백트래킹 암호만들기 1759 -> set으로 문자열 중복체크같은거 함 셋으로 하면 알아서 중복제거된다!
그래서 교집합 합집합 이런거 구할때 유용함
temp = []
a = set(['a', 'e', 'i', 'o', 'u'])
b = set(['b','c','d','f','g','h','j','k','l','m','n','p','q','r','s','t','v','w','x','y','z'])
temp.append(arr[i])
if len(temp) == N and len((set(temp) & a)) >= 1 and len((set(temp) & b)) >= 2 :

set으로 중복제거, 교집합 이런거 구하고나서 sort하고 싶으면 다시 list( set자료구조)로 리스트화 시키기
중복제거 -> set(a) -> list(a) 하면 중복제거되서 list로 변환
교집합 -> set(a) & set(b)
합집합 -> set(a) | set(b)
차집합 -> set(a) - set(b)   or  set(b) - set(a)
대칭 차집합 -> set(a) ^ set(b)
추가하고십으면 a.add(원소)
여러개 추가하고 싶으면 a.update( [3,4,5] )


1.2 int문제관련
123 -> [1, 2, 3]
board = [list(map(int, input().rstrip())) for _ in range(N)

2. copy (딥카피)(주소까지 다르게 복사)
import copy
temp = copy.deepcopy(board)


3.1 조합(순서 상관X)
from itertools import combinations
safezone = []
safezone.append((i,j))
리스트에서 조합을 구하기 위하여 리스트안에 튜플형식으로 삽입
addWallList = list(combinations(safezone, 3))


3.2 순열(순서 상관O)
from itertools import permutations
arr = [1,3,4,2,5]
temp = list(permutations(arr,3))


4. 연산
(0-1)%4 -> 3이다!!   (0+1)%4 가 1이고!

5.-1 우선순위큐
start, finish = map(int, input().split())
asd = []
heapq.heappush(asd, (finish, start)) -> 우선순위1 : finish 그리고 우선순위2 : start
-> sorted(asd, key=lambda x : (x[1], x[0]))이랑 같지만 자료구조가 달라서 힙큐가 시간제한에 훨신 관용적임!!!!11000회의실배정참고
logn! 속도임 바킹독꺼 보고 블로그에 정리해놓기!

5. 정렬!! ㄴㄴㄴㄴ 정렬은 솔트고 나발이고 힙큐(우선순위큐)로 가기!!!
https://gorokke.tistory.com/38 여기참고하기(숫자,문자,오름차순,내림차순 정리되어있슴)
힙큐
https://velog.io/@dding_ji/baekjoon11000 (파이썬으로 우선순위 큐 자료구조에 오름차순 넣기)
weightList.sort(reverse=True) -> 역순
time = sorted(time, key=lambda a: a[0]) -> 그리디 1931 최대회의실배정
time = sorted(time, key=lambda a: a[1])

5.1 정렬2!!
시뮬 17140 참고
from collections import Counter (C대문자 주의)
temp = [1, 1, 1, 2, 2, 3]
X = Counter(temp)
print(X) -> Counter({1: 3, 2: 2, 3: 1})  이거 dict[key]처럼 X[3] -> 1이다!!
!!!!근데 애초에 위에서 X = Counter(temp).most_common()하면 밑에 생략가능 from collections import Counter
X = list(X.items())  (이거를 다시 리스트화) 
print(X) -> [(2,2),(1,3),(3,1)]
X = sorted(X, key=lambda x: (x[1], x[0])) -> 인덱스1, 인덱스0 오름차순 정렬 (시뮬 17140 문제 참고)
print(X) -> [(3,1),(2,2),(1,3)] 
temp = reduce(lambda x,y : list(x) + list(y), X[1:], list(X[0])) -> 위의 튜플형태를 리스트로 만들기(이건 그냥 외우기..) from functools import reduce
print(temp) -> [3, 1, 2, 2, 1, 3]

5.2 정렬문제시 사용 내장함수
1) del temp[0] -> 리스트에 0번째 인덱스 제거 -> pop은 인덱스를 반환하지만 del은 반환X 고로 del이 미세하게 빠름 또한 슬라이싱도 가능
2) board = list(map(list, zip(*board))) -> 전치행렬 만드는것 (열들을 행처럼 리스트로 가지고 놀고 싶을때 사용)(17140문제 참고)
3) board = board[:50] -> 0~49인덱스까지만 슬라이싱 하는것 
4) temp.extend([1,2,3]) -> 기존 리스트에 1,2,3추가
5) list1.remove(3) -> 리스트에 특정 값 제거 
list1 = [ 4, 3, 2, 1]
list1.remove(3) -> [4, 2, 1]
6) sort(reverse=True)->(오름차순 정렬후 reverse)랑 reverse()->(그냥 리버스)는 완전다름! 주의하기



6. bfs 2206 벽부수기 한번 보기



7. 코테 제출언어에 pypy3있으면 이걸로 제출하기!!!!!!!!!!
ㄴ


8. import math
올림 math.ceil(값) -> ceil천장이니까 올림이래
내림 math.floor(값) -> floor 마루,바닥이니까 내림이래


9. 시뮬같은거 할때 하드코드 금지! ex ) 시뮬_17140에서 if로 시작할때 답도출될경우 0프린트하는거! 꼭 보기! -> try로 바꿈


10. 중복제거! -> set
A = [1, 1, 2, 3]
A = list(set(A)) -> [1,2,3]

11 딕셔너리
    for _ in range(n):
        v, k = input().split()
        # 의류 종류가 dict에 없다면 새로 넣어주고, 아니면 원래 있던 의류 종류 키에 대해,
        # set 밸류에 v 추가해주기
        if clothes.get(k) == None:
            clothes[k] = set()  ★★★★★
        clothes[k].add(v)
그리고 len(clothes['성훈이의템']) -> 2
그리고 for key in clothes.keys() :
	cnt += len(clothes[key]) 이런것도 가능


11.2 딕셔너리
(구현 20291 참고)
import sys
input = sys.stdin.readline

N = int(input().rstrip())
file = {} # 딕셔너리 생성

for _ in range(N):
    filename = input().rstrip().split('.') # filename[0] = 파일명, filename[1] = 확장자
    
    if filename[1] in file: # 확장자가 file에 있는 경우
        file[filename[1]] += 1 # +1
    else: # 확장자가 file에 없는 경우
        file[filename[1]] = 1 # 확장자 추가 & 1로 설정

file = sorted(file.items(), key = lambda x:x[0], reverse=False) # 확장자 사전순 출력 -> items()는 딕셔너리를 튜플타입으로 바꾸기 위함(sorted안에는 튜플만 되나봄)

for i in file:
    print(i[0], i[1]) # 파일명, 개수 출력



12. sys.exit() -> 이거 무조건 끝내는거인듯

13. if not all(visited) : -> visited안에 모두 False일경우 True라 생각하고 실행함 (반복가능형 자료에서 모두 ~~일경우(not 안붙이면 True) True반한







 

